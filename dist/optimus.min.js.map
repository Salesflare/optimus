{"version":3,"file":"optimus.min.js","sources":["../lib/transformer.js"],"sourcesContent":["'use strict';\n\nconst internals = {\n    transformers: [\n        /**\n         *\n         * @param {Object} rule\n         * @param {String} rule.id\n         * @param {String} rule.operator\n         * @param {any | any[]} rule.value\n         * @returns {Object} rule\n         */\n        function personType(rule) {\n\n            if (rule.id === 'person-customer.customers' || rule.id === 'person-contact.my-contacts') {\n                return {\n                    id: 'person-type.id',\n                    entity: 'person',\n                    input: 'multiselect',\n                    label: 'Type',\n                    operator: 'in',\n                    type: 'integer',\n                    value: [rule.id === 'person-customer.customers' ? 2 : 1]\n                };\n            }\n\n            return rule;\n        },\n        /**\n         *\n         * @param {Object} rule\n         * @param {String} rule.id\n         * @param {String} rule.operator\n         * @param {any | any[]} rule.value\n         * @returns {Object} rule\n         */\n        function booleanOperator(rule) {\n\n            const operatorTransformations = {\n                'is_empty': {\n                    operator: 'equal',\n                    value: ['null']\n                },\n                'is_not_empty': {\n                    operator: 'not_equal',\n                    value: ['null']\n                },\n                'is_null': {\n                    operator: 'equal',\n                    value: ['null']\n                },\n                'is_not_null': {\n                    operator: 'not_equal',\n                    value: ['null']\n                },\n                'true': {\n                    operator: 'equal',\n                    value: ['true']\n                },\n                'false': {\n                    operator: 'equal',\n                    value: ['false']\n                }\n            };\n\n            if (Object.keys(operatorTransformations).includes(rule.operator)) {\n                const matchedTransform = operatorTransformations[rule.operator];\n                rule.operator = matchedTransform.operator;\n                rule.value = matchedTransform.value;\n            }\n\n            return rule;\n        },\n        function transformValuesForBetweenOperator(rule) {\n\n            if ((rule.operator === 'between' || rule.operator === 'not_between')) {\n\n                let value1;\n                let value2;\n\n                // Able to handle client and server side\n                if (typeof rule.value !== 'undefined' && typeof rule.value[0] !== 'undefined'\n                    && (typeof rule.value[0].value1 !== 'undefined' || typeof rule.value[0].value2 !== 'undefined')) {\n\n                    value1 = rule.value[0].value1;\n                    value2 = rule.value[0].value2;\n                    delete rule.value[0].value1;\n                    delete rule.value[0].value2;\n                }\n                else {\n                    value1 = rule.value1;\n                    value2 = rule.value2;\n                    delete rule.value1;\n                    delete rule.value2;\n                }\n\n                // Depending on the current values, we reformat the values a certain way\n                if (typeof value1 !== 'undefined' && value1 !== null\n                    && typeof value2 !== 'undefined' && value2 !== null) {\n\n                    rule.value = [value1,value2];\n                }\n                else if ((typeof value1 === 'undefined' && typeof value2 === 'undefined')) {\n                    // The original values are already accepted\n                    return rule;\n                }\n                else {\n                    rule.value = [];\n                }\n            }\n\n            return rule;\n        }\n    ]\n};\n\n/**\n * Transform filter object from older version to newest version\n *\n * @param {Object} filtersObject\n * @param {Object[]} filtersObject.rules\n * @returns {Object} transformed filter object\n */\nexports.transform = internals.transform = (filtersObject) => {\n\n    const transformed = { ...filtersObject };\n    internals.transformers.forEach((transformer) => {\n\n        transformed.rules = transformed.rules.map(transformer);\n    });\n\n    return transformed;\n};\n"],"names":["internals","transformers","rule","id","entity","input","label","operator","type","value","operatorTransformations","Object","keys","includes","matchedTransform","value1","value2","transform","filtersObject","transformed","forEach","transformer","rules","map"],"mappings":"6JAEA,IAAMA,EAAY,CACdC,aAAc,UASUC,SAEA,8BAAZA,EAAKC,IAAkD,+BAAZD,EAAKC,GACzC,CACHA,GAAI,iBACJC,OAAQ,SACRC,MAAO,cACPC,MAAO,OACPC,SAAU,KACVC,KAAM,UACNC,MAAO,CAAa,8BAAZP,EAAKC,GAAqC,EAAI,IAIvDD,YAUcA,OAEfQ,EAA0B,UAChB,CACRH,SAAU,QACVE,MAAO,CAAC,sBAEI,CACZF,SAAU,YACVE,MAAO,CAAC,iBAED,CACPF,SAAU,QACVE,MAAO,CAAC,qBAEG,CACXF,SAAU,YACVE,MAAO,CAAC,cAEJ,CACJF,SAAU,QACVE,MAAO,CAAC,eAEH,CACLF,SAAU,QACVE,MAAO,CAAC,cAIZE,OAAOC,KAAKF,GAAyBG,SAASX,EAAKK,UAAW,KACxDO,EAAmBJ,EAAwBR,EAAKK,UACtDL,EAAKK,SAAWO,EAAiBP,SACjCL,EAAKO,MAAQK,EAAiBL,aAG3BP,GAEX,SAA2CA,OAI/Ba,EACAC,KAHe,YAAlBd,EAAKK,UAA4C,gBAAlBL,EAAKK,iBAMX,IAAfL,EAAKO,YAAkD,IAAlBP,EAAKO,MAAM,SACnB,IAAzBP,EAAKO,MAAM,GAAGM,aAA0D,IAAzBb,EAAKO,MAAM,GAAGO,QAQxED,EAASb,EAAKa,OACdC,EAASd,EAAKc,cACPd,EAAKa,cACLb,EAAKc,SATZD,EAASb,EAAKO,MAAM,GAAGM,OACvBC,EAASd,EAAKO,MAAM,GAAGO,cAChBd,EAAKO,MAAM,GAAGM,cACdb,EAAKO,MAAM,GAAGO,QAUrB,MAAOD,GAAP,MACUC,EAEVd,EAAKO,MAAQ,CAACM,EAAOC,OAEpB,CAAA,QAAuB,IAAXD,QAA4C,IAAXC,SAEvCd,EAGPA,EAAKO,MAAQ,UAIdP,OAYCF,EAAUiB,UAAY,SAACC,OAEjCC,wUAAmBD,UACzBlB,EAAUC,aAAamB,QAAQ,SAACC,GAE5BF,EAAYG,MAAQH,EAAYG,MAAMC,IAAIF,KAGvCF"}